using Noggog;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Environments;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins.Cache;
using System.Runtime.CompilerServices;

namespace NavmeshCollector
{
    public class Program
    {
        private static Lazy<Settings> _patcherSettings = null!;
        private static Settings PatcherSettings => _patcherSettings.Value;

        private static readonly ModKey[] BethesdaPlugins =
        [
            Skyrim.ModKey,
            Update.ModKey,
            Dawnguard.ModKey,
            Dragonborn.ModKey,
            HearthFires.ModKey
        ];

        private static readonly HashSet<ModKey> CreationClubPlugins =
            GetCreationClubPlugins(GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE).CreationClubListingsFilePath ?? string.Empty);

        /// <summary>
        /// Reads Creation Club plugin keys from the listings file.
        /// </summary>
        public static HashSet<ModKey> GetCreationClubPlugins(FilePath creationClubListingsFilePath)
        {
            try
            {
                if (!File.Exists(creationClubListingsFilePath))
                    return [];

                return [.. File.ReadAllLines(creationClubListingsFilePath)
                    .Select(line => ModKey.TryFromFileName(new FileName(line)))
                    .Where(plugin => plugin.HasValue)
                    .Select(plugin => plugin!.Value)];
            }
            catch
            {
                return [];
            }
        }

        /// <summary>
        /// Determines if a collection represents a non-conflicting override.
        /// A non-conflicting collection has exactly two distinct elements and the elements are ordered regularly
        /// (i.e., all instances of the first distinct element appear before all instances of the second).
        /// </summary>
        /// <typeparam name="T">The type of elements in the collection.</typeparam>
        /// <param name="collection">The collection to evaluate.</param>
        /// <returns>True if the collection is non-conflicting; otherwise, false.</returns>
        private static bool IsNonConflicting<T>(IEnumerable<T> collection)
        {
            var list = collection.ToList();

            if (list.Count == 0)
                return false;
            if (list.Count == 2)
                return true;

            var distinctElements = list.Distinct().ToList();

            // Must have exactly two distinct elements
            if (distinctElements.Count != 2)
                return false;

            // Check if elements are ordered regularly (all of first element, then all of second)
            var firstElement = distinctElements[0];
            var secondElement = distinctElements[1];

            bool foundSecond = false;
            foreach (var item in list)
                if (EqualityComparer<T>.Default.Equals(item, secondElement))
                    foundSecond = true;
                else if (foundSecond && EqualityComparer<T>.Default.Equals(item, firstElement))
                    // Found first element after second element - not regularly ordered
                    return false;

            return true;
        }

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _patcherSettings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "NavmeshCollector.esp")
                .Run(args);
        }

        /// <summary>
        /// Main patching logic for collecting navmeshes.
        /// </summary>
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var cellSettings = PatcherSettings.CellSettings;
            var overrideSettings = PatcherSettings.OverrideSettings;

            if (!cellSettings.InteriorCells && !cellSettings.ExteriorCells)
            {
                Console.WriteLine("Error: Either \"Include Interior Cells\" or \"Include Exterior Cells\" must be enabled in Settings\n");
                return;
            }

            var basePlugins = new HashSet<ModKey>(BethesdaPlugins.Concat(CreationClubPlugins));
            var cache = state.LinkCache;

            var candidateNavmeshes = state.LoadOrder.PriorityOrder
                .OnlyEnabledAndExisting()
                .NavigationMesh()
                .WinningContextOverrides(cache);

            int collectedCount = 0;

            foreach (var navmesh in candidateNavmeshes)
            {
                if (ShouldCollectNavmesh(navmesh, cellSettings, overrideSettings, basePlugins, cache, out var parentModKey))
                {
                    Console.WriteLine($"Collecting navmesh {navmesh.Record.FormKey} from override in {parentModKey}");
                    navmesh.GetOrAddAsOverride(state.PatchMod);
                    collectedCount++;
                }
            }

            Console.WriteLine($"Collected {collectedCount} navmeshes");
        }

        /// <summary>
        /// Determines whether a navmesh should be collected based on settings and override analysis.
        /// </summary>
        private static bool ShouldCollectNavmesh(
            IModContext<ISkyrimMod, ISkyrimModGetter, INavigationMesh, INavigationMeshGetter> navmesh,
            CellSettings cellSettings,
            OverrideSettings overrideSettings,
            HashSet<ModKey> basePlugins,
            ILinkCache cache,
            out ModKey parentModKey)
        {
            parentModKey = default;

            // Basic validation
            if (navmesh.Record.Data is null || navmesh.Parent?.ModKey is null)
                return false;

            parentModKey = navmesh.Parent.ModKey;

            // Bethesda override filtering
            var isFromBethesda = basePlugins.Contains(parentModKey);
            if (!overrideSettings.IncludeBethesdaOverrides && isFromBethesda)
                return false;

            // Cell type filtering
            if (!cellSettings.InteriorCells && navmesh.Record.Data.Parent is CellNavmeshParent)
                return false;

            if (!cellSettings.ExteriorCells && navmesh.Record.Data.Parent is WorldspaceNavmeshParent)
                return false;

            // Modded cells filtering
            var isBasePlugin = basePlugins.Contains(navmesh.Record.FormKey.ModKey);
            if (!cellSettings.ModdedCells && !isBasePlugin)
                return false;

            // Override analysis
            var overrides = cache.ResolveAllSimpleContexts<INavigationMeshGetter>(navmesh.Record.FormKey).ToList();

            if (!overrideSettings.IncludeSingles && overrides.Count == 1)
                return false;

            var distinctOverrides = overrides
                .Distinct(o => o.Record.Data)
                .ToList();

            if (!overrideSettings.IncludeIdenticals && distinctOverrides.Count == 1)
                return false;

            // Check for overrides without conflict
            var isNoConflictOverride = IsNonConflicting(overrides.Select(o => o.Record.Data));
            if (!overrideSettings.IncludeNoConflicts && isNoConflictOverride)
                return false;

            // Check for overrides with conflicts from multiple Bethesda plugins
            var isBethesdaConflict = (distinctOverrides.Count - distinctOverrides.Where(o => basePlugins.Contains(o.Parent!.ModKey)).Count()) == 1;
            if (!overrideSettings.IncludeBethesdaConflicts && isBethesdaConflict)
                return false;

            return true;
        }
    }
}
